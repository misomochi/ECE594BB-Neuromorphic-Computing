# -*- coding: utf-8 -*-
"""ECE594BB_HW1_P2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qbqqD3N30ZBMAt1PZdV05Ipj0XAypU8Y
"""

import numpy as np
import matplotlib.pyplot as plt

neurons = 5

# LIF parameters
V_rest = -65 #resting membrane potential (mV)
R = [1e6, 1e6, 1e6, 1e7, 1e7] # resistance (Î©)
tau = [50, 50, 50, 20, 20] # time constant (ms)
dt = 0.1 # unit time (ms)
n_steps = 20000 # time steps
V_th = [-35, -35, -35, -60, -60] # threshold voltage (mV)

# membrane potential
V = np.zeros((neurons, n_steps))
V[:, 0] = V_rest

# input current
I = np.zeros(n_steps)
I[5000:15000] = 5e-5 #(mA)

# synaptic weights (mA/mV)
w = np.zeros((neurons, neurons))
#w[:3, 3:] = [[-1e-5, 3e-5], [1e-4, -4e-5], [1e-5, 5e-5]] # Part 1)
w[:3, 3:] = [[1e-5, 5e-6], [1e-5, 5e-6], [1e-5, -1e-5]] # Part 2)

# spike train
spikes = np.zeros((neurons, n_steps))

for i in range(1, n_steps):
    for j in range(neurons):
        if V[j, i - 1] >= V_th[j]:
            V[j, i] = V_rest
            spikes[j, i - 1] = 1 #(mV)
        else:
            if j < 3:
                V[j, i] = V[j, i - 1] + dt/tau[j] * (R[j] * I[i - 1] - V[j, i - 1] + V_rest)
            else:
                V[j, i] = V[j, i - 1] + dt/tau[j] * (R[j] * np.dot(w[:3, j], spikes[:3, i - 1]) - V[j, i - 1] + V_rest)

t = [n * dt for n in range(n_steps)]
fig, ax = plt.subplots(3, figsize=(9, 16))

for count, value in enumerate([0, 3, 4]):
    ax[count].plot(t, V[value])
    ax[count].axhline(y=V_th[value], color='r', linestyle='dashed')
    ax[count].legend([r'$V(t)$', r'$V_{th}$'])
    ax[count].set_title(f'Neuron {value + 1}')
    ax[count].set_xlabel('t (ms)')
    ax[count].set_ylabel('V (mV)')

fig.tight_layout()

for n in range(5):
    print(f'Neuron {n + 1} firing times: {np.count_nonzero(spikes[n])}')